# 权限变更后自动登出方案

## 🎯 目标

当后端权限配置变更后，强制所有在线用户重新登录以获取最新权限。

## 📋 当前问题

1. **权限缓存在前端**：用户登录时获取权限并存储在 `localStorage`
2. **后端权限变更**：运行权限种子脚本更新数据库
3. **前端不感知**：在线用户仍使用旧的权限配置
4. **可能导致问题**：
   - 新功能无法访问（403错误）
   - 已撤销的权限仍然可用

## ✅ 解决方案

### 方案1：手动通知（当前已实现）⭐

**实现**：在权限种子脚本运行后显示提示信息

**位置**：`backend/prisma/seeds/permissions.seed.ts`

```typescript
console.log('⚠️  重要提示：权限已更新！');
console.log('📢 请通知所有在线用户重新登录以获取最新权限：');
console.log('   1️⃣  点击右上角头像');
console.log('   2️⃣  选择"退出登录"');
console.log('   3️⃣  重新登录');
```

**优点**：
- ✅ 简单，无需修改代码
- ✅ 不影响用户体验

**缺点**：
- ❌ 需要手动通知用户
- ❌ 用户可能忽略通知

**适用场景**：开发/测试环境

---

### 方案2：权限版本控制（推荐用于生产环境）

**实现步骤**：

#### 1. 数据库添加权限版本字段

```prisma
// prisma/schema.prisma
model User {
  // ... 其他字段
  permissionVersion Int? @default(0) // 权限版本号
}

model SystemConfig {
  id                 String   @id @default(uuid())
  key                String   @unique
  value              String
  description        String?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
}
```

运行迁移：
```bash
npx prisma migrate dev --name add_permission_version
```

#### 2. 更新权限种子脚本

```typescript
// backend/prisma/seeds/permissions.seed.ts
export async function seedPermissions() {
  // ... 现有逻辑 ...
  
  // 更新系统权限版本
  const currentVersion = await prisma.systemConfig.findUnique({
    where: { key: 'PERMISSION_VERSION' }
  });
  
  const newVersion = (parseInt(currentVersion?.value || '0') + 1).toString();
  
  await prisma.systemConfig.upsert({
    where: { key: 'PERMISSION_VERSION' },
    create: {
      key: 'PERMISSION_VERSION',
      value: newVersion,
      description: '权限配置版本号'
    },
    update: {
      value: newVersion,
      updatedAt: new Date()
    }
  });
  
  console.log(`✅ 权限版本已更新：${currentVersion?.value || '0'} -> ${newVersion}`);
  console.log('⚠️  所有用户将在下次请求时被要求重新登录');
}
```

#### 3. 后端添加版本检查中间件

```typescript
// backend/src/common/middleware/permission-version.middleware.ts
import { Injectable, NestMiddleware, UnauthorizedException } from '@nestjs/common';
import { PrismaService } from '@/infrastructure/prisma/prisma.service';

@Injectable()
export class PermissionVersionMiddleware implements NestMiddleware {
  constructor(private prisma: PrismaService) {}

  async use(req: any, res: any, next: () => void) {
    // 跳过登录接口
    if (req.path === '/api/auth/login') {
      return next();
    }

    const user = req.user;
    if (!user) {
      return next();
    }

    // 获取系统当前权限版本
    const systemConfig = await this.prisma.systemConfig.findUnique({
      where: { key: 'PERMISSION_VERSION' }
    });
    const currentVersion = parseInt(systemConfig?.value || '0');

    // 获取用户的权限版本
    const userVersion = user.permissionVersion || 0;

    // 如果版本不匹配，返回特殊错误码
    if (userVersion < currentVersion) {
      throw new UnauthorizedException({
        message: '权限配置已更新，请重新登录',
        code: 'PERMISSION_VERSION_MISMATCH',
        requiredVersion: currentVersion,
        currentVersion: userVersion
      });
    }

    next();
  }
}
```

注册中间件：
```typescript
// backend/src/app.module.ts
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply(PermissionVersionMiddleware)
      .forRoutes('*');
  }
}
```

#### 4. 登录时更新用户权限版本

```typescript
// backend/src/modules/auth/auth.service.ts
async login(loginDto: LoginDto) {
  // ... 验证用户 ...
  
  // 获取当前系统权限版本
  const systemConfig = await this.prisma.systemConfig.findUnique({
    where: { key: 'PERMISSION_VERSION' }
  });
  const currentVersion = parseInt(systemConfig?.value || '0');
  
  // 更新用户的权限版本
  await this.prisma.user.update({
    where: { id: user.id },
    data: { permissionVersion: currentVersion }
  });
  
  // ... 返回 token 和用户信息 ...
}
```

#### 5. 前端处理版本不匹配

```typescript
// admin-frontend/src/utils/request.ts
service.interceptors.response.use(
  (response) => response.data,
  (error) => {
    const { response } = error;
    
    if (response?.status === 401) {
      const data = response.data;
      
      // 检查是否是权限版本不匹配
      if (data.code === 'PERMISSION_VERSION_MISMATCH') {
        ElMessageBox.alert(
          '系统权限配置已更新，请重新登录以获取最新权限',
          '权限更新通知',
          {
            confirmButtonText: '重新登录',
            type: 'warning',
            showClose: false,
            closeOnClickModal: false,
            closeOnPressEscape: false,
            callback: () => {
              // 清除登录状态
              const authStore = useAuthStore();
              authStore.logout(true);
              
              // 跳转到登录页
              router.push('/login');
            }
          }
        );
        return Promise.reject(new Error('权限版本不匹配'));
      }
      
      // ... 其他401处理 ...
    }
    
    return Promise.reject(error);
  }
);
```

**优点**：
- ✅ 自动检测权限变更
- ✅ 强制用户重新登录
- ✅ 友好的提示信息
- ✅ 适合生产环境

**缺点**：
- ❌ 需要修改数据库结构
- ❌ 实现较复杂

---

### 方案3：Token 失效时间（简化版）

**实现**：设置较短的 Token 过期时间

```typescript
// backend/src/modules/auth/auth.service.ts
const token = this.jwtService.sign(payload, {
  expiresIn: '2h', // 2小时后自动失效，强制重新登录
});
```

**配合定时刷新权限**：

```typescript
// admin-frontend/src/App.vue
onMounted(() => {
  // 每30分钟刷新一次用户信息（包括权限）
  setInterval(async () => {
    if (authStore.token) {
      try {
        await authStore.fetchUserInfo();
        console.log('权限已刷新');
      } catch (error) {
        // Token 可能已过期，跳转登录
        router.push('/login');
      }
    }
  }, 30 * 60 * 1000);
});
```

**优点**：
- ✅ 实现简单
- ✅ 自动更新权限

**缺点**：
- ❌ 不是实时的
- ❌ 可能中断用户操作

---

### 方案4：WebSocket 推送（最优雅）

**实现**：使用 WebSocket 推送权限变更通知

#### 1. 后端 WebSocket Gateway

```typescript
// backend/src/modules/notification/notification.gateway.ts
@WebSocketGateway({
  cors: { origin: '*' }
})
export class NotificationGateway {
  @WebSocketServer()
  server: Server;

  // 通知所有客户端权限已更新
  notifyPermissionUpdate() {
    this.server.emit('permission:updated', {
      message: '权限配置已更新，请重新登录',
      timestamp: new Date().toISOString()
    });
  }
}
```

#### 2. 权限种子脚本调用

```typescript
// backend/prisma/seeds/permissions.seed.ts
import { NotificationGateway } from '@/modules/notification/notification.gateway';

export async function seedPermissions() {
  // ... 更新权限 ...
  
  // 通知所有在线用户
  const notificationGateway = new NotificationGateway();
  notificationGateway.notifyPermissionUpdate();
}
```

#### 3. 前端监听

```typescript
// admin-frontend/src/App.vue
import { io } from 'socket.io-client';

onMounted(() => {
  const socket = io('http://localhost:3000');
  
  socket.on('permission:updated', (data) => {
    ElMessageBox.alert(
      data.message,
      '权限更新通知',
      {
        confirmButtonText: '重新登录',
        type: 'warning',
        callback: async () => {
          await authStore.logout();
          router.push('/login');
        }
      }
    );
  });
});
```

**优点**：
- ✅ 实时推送
- ✅ 用户体验好
- ✅ 可以批量通知

**缺点**：
- ❌ 需要 WebSocket 基础设施
- ❌ 实现复杂

---

## 🎯 推荐方案选择

### 开发/测试环境
- **方案1**：手动通知 ✅ **已实现**
- 简单快速，适合快速迭代

### 生产环境（小规模）
- **方案2**：权限版本控制
- 自动化程度高，稳定可靠

### 生产环境（大规模）
- **方案4**：WebSocket 推送
- 用户体验最好，实时性强

---

## 📝 当前使用方法

### 步骤1：运行权限种子脚本

```bash
cd backend
npx ts-node prisma/seeds/permissions.seed.ts
```

### 步骤2：查看提示信息

```
✅ 权限数据初始化完成！

⚠️  重要提示：权限已更新！
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📢 请通知所有在线用户重新登录以获取最新权限：
   1️⃣  点击右上角头像
   2️⃣  选择"退出登录"
   3️⃣  重新登录

💡 或者在浏览器控制台执行以下命令强制刷新：
   localStorage.clear(); location.reload();
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

### 步骤3：通知用户

方式1：**口头通知**
- 告知在线用户重新登录

方式2：**技术通知**
- 让用户打开浏览器控制台（F12）
- 执行：`localStorage.clear(); location.reload();`

方式3：**强制刷新（开发环境）**
- 在浏览器控制台执行上述命令

---

## 🔮 未来改进

1. **实现方案2**（权限版本控制）
   - 添加数据库字段
   - 实现自动检测和登出

2. **添加管理后台通知功能**
   - 管理员可以在后台发送通知
   - 通知所有在线用户权限已更新

3. **实现定时刷新**
   - 每隔一定时间自动刷新用户权限
   - 避免长时间使用旧权限

---

**当前状态**：✅ 方案1已实现  
**推荐升级**：→ 方案2（权限版本控制）  
**最终目标**：→ 方案4（WebSocket 推送）





